
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>02: Logistic Regression &#8212; Learning Deep Learning</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="03: Back Propagation" href="03_backprop.html" />
    <link rel="prev" title="01: Linear Regression" href="01_linear_regression.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Learning Deep Learning</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    Learning Deep Learning [WIP!]
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Neural Networks
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="01_linear_regression.html">
   01: Linear Regression
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   02: Logistic Regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="03_backprop.html">
   03: Back Propagation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="04_matrix_notation.html">
   04: Matrix Notation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="05_activation.html">
   05: Gradients and Activation Functions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="06_nonlinear_regression.html">
   06: Non-linear Regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="07_multiclass.html">
   07: Multiple Outputs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="08_regularisation.html">
   08 Regularisation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="09_optimisers.html">
   09: Optimisation Algorithms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="10_experiments.html">
   10: Training and Tuning Networks
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/jack89roberts/learning-deep-learning/main?urlpath=tree/notebooks/02_logistic_regression.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/jack89roberts/learning-deep-learning"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/jack89roberts/learning-deep-learning/issues/new?title=Issue%20on%20page%20%2Fnotebooks/02_logistic_regression.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/jack89roberts/learning-deep-learning/edit/main/notebooks/02_logistic_regression.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="headerbtn__text-container">suggest edit</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/notebooks/02_logistic_regression.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#why-not-just-use-linear-regression-for-classification">
   Why not just use linear regression for classification?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-solution-sigmoid">
   The solution: Sigmoid
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loss-function">
   Loss Function
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#why-not-just-use-mean-squared-error">
   Why not just use mean squared error?
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#it-s-the-maximum-likelihood-estimator">
     1) It’s the Maximum Likelihood Estimator
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#it-s-convex">
     2) It’s convex
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#gradient-descent-for-logistic-regression">
   Gradient Descent for Logistic Regression
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#neural-network-for-logistic-regression">
   Neural Network for Logistic Regression
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pytorch">
   Pytorch
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#adding-a-second-feature">
   Adding a second feature
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pytorch-2-input-logistic-regression-network">
   Pytorch 2-input Logistic Regression Network
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-type-of-decision-boundary-can-this-network-fit-given-x-1-and-x-2">
   What type of decision boundary can this network fit (given
   <span class="math notranslate nohighlight">
    \(x_1\)
   </span>
   and
   <span class="math notranslate nohighlight">
    \(x_2\)
   </span>
   )?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#result">
   Result
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#adding-nodes-and-layers-moving-away-from-logistic-regression">
   Adding nodes and layers (moving away from logistic regression)
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hidden-layer">
     1 Hidden Layer
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#what-type-of-decision-boundary-can-this-network-fit-given-only-the-original-features-x-1-and-x-2">
       What type of decision boundary can this network fit (given only the original features
       <span class="math notranslate nohighlight">
        \(x_1\)
       </span>
       and
       <span class="math notranslate nohighlight">
        \(x_2\)
       </span>
       )?
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hidden-layers">
     2 Hidden Layers
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-s-going-on">
   What’s going on?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#takeaway-message">
   Takeaway message
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   References
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>02: Logistic Regression</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#why-not-just-use-linear-regression-for-classification">
   Why not just use linear regression for classification?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-solution-sigmoid">
   The solution: Sigmoid
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loss-function">
   Loss Function
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#why-not-just-use-mean-squared-error">
   Why not just use mean squared error?
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#it-s-the-maximum-likelihood-estimator">
     1) It’s the Maximum Likelihood Estimator
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#it-s-convex">
     2) It’s convex
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#gradient-descent-for-logistic-regression">
   Gradient Descent for Logistic Regression
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#neural-network-for-logistic-regression">
   Neural Network for Logistic Regression
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pytorch">
   Pytorch
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#adding-a-second-feature">
   Adding a second feature
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pytorch-2-input-logistic-regression-network">
   Pytorch 2-input Logistic Regression Network
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-type-of-decision-boundary-can-this-network-fit-given-x-1-and-x-2">
   What type of decision boundary can this network fit (given
   <span class="math notranslate nohighlight">
    \(x_1\)
   </span>
   and
   <span class="math notranslate nohighlight">
    \(x_2\)
   </span>
   )?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#result">
   Result
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#adding-nodes-and-layers-moving-away-from-logistic-regression">
   Adding nodes and layers (moving away from logistic regression)
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hidden-layer">
     1 Hidden Layer
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#what-type-of-decision-boundary-can-this-network-fit-given-only-the-original-features-x-1-and-x-2">
       What type of decision boundary can this network fit (given only the original features
       <span class="math notranslate nohighlight">
        \(x_1\)
       </span>
       and
       <span class="math notranslate nohighlight">
        \(x_2\)
       </span>
       )?
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hidden-layers">
     2 Hidden Layers
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-s-going-on">
   What’s going on?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#takeaway-message">
   Takeaway message
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   References
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="logistic-regression">
<h1>02: Logistic Regression<a class="headerlink" href="#logistic-regression" title="Permalink to this headline">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import itertools
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from sklearn.linear_model import LinearRegression
from sklearn.metrics import log_loss, mean_squared_error
import torch
from torch import nn
</pre></div>
</div>
</div>
</div>
<p>In the first part we created a neural network for linear regression (i.e. for a continuous output value <span class="math notranslate nohighlight">\(y\)</span>). In this part we’ll move on to binary classification (i.e. where <span class="math notranslate nohighlight">\(y\)</span> can belong to one of two classes <span class="math notranslate nohighlight">\(y \in \{0, 1\}\)</span>), starting with logistic regression.</p>
<section id="why-not-just-use-linear-regression-for-classification">
<h2>Why not just use linear regression for classification?<a class="headerlink" href="#why-not-just-use-linear-regression-for-classification" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>Linear regression returns a continuous value (<span class="math notranslate nohighlight">\(-\infty \leq y \leq \infty\)</span>), but we want a class probability (<span class="math notranslate nohighlight">\(0 \leq y \leq 1\)</span>)</p></li>
<li><p>Very sensitive to outliers/imbalanced data</p></li>
</ul>
<p>Here’s an example of using linear regression on a classification dataset with a single feature, <span class="math notranslate nohighlight">\(x\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def fit_and_plot(x, y, title=&quot;&quot;, ax=None):
    if ax is None:
        _, ax = plt.subplots(1, 1)
    lr = LinearRegression()
    lr.fit(x.reshape(-1, 1), y)
    yhat = lr.predict(x.reshape(-1, 1))
    ax.scatter(x, y, c=yhat &gt;= 0.5, cmap=&quot;bwr&quot;)
    ax.plot(x, yhat, &quot;k--&quot;, label=&quot;linear fit&quot;)
    ax.set_ylim([-0.2, 1.2])
    ax.legend(loc=&quot;lower right&quot;)
    ax.set_ylabel(&quot;y&quot;)
    ax.set_xlabel(&quot;x&quot;)
    ax.set_title(title)


xy = np.loadtxt(&quot;../data/02_dummy_data.csv&quot;)
x = xy[:, 0]
y = xy[:, 1]

fig, ax = plt.subplots(1, 2, figsize=(9, 4))
fit_and_plot(x, y, title=&quot;balanced&quot;, ax=ax[0])
fit_and_plot(np.append(x, [4, 5]), np.append(y, [1, 1]), title=&quot;+ outliers&quot;, ax=ax[1])
fig.tight_layout()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/02_logistic_regression_4_0.png" src="../_images/02_logistic_regression_4_0.png" />
</div>
</div>
<p>Note that:</p>
<ul class="simple">
<li><p>The range of <span class="math notranslate nohighlight">\(y\)</span> is not limited to between 0 and 1</p></li>
<li><p>The presence of the outliers changes the predicted class of a point (and e.g. changes the value of <span class="math notranslate nohighlight">\(y\)</span> from around -0.2 to +0.2 for <span class="math notranslate nohighlight">\(x = -1.5\)</span>)</p></li>
</ul>
</section>
<section id="the-solution-sigmoid">
<h2>The solution: Sigmoid<a class="headerlink" href="#the-solution-sigmoid" title="Permalink to this headline">#</a></h2>
<p>To get around this we apply the <strong>sigmoid</strong> function:</p>
<div class="math notranslate nohighlight">
\[
\textrm{sigmoid}(z) = \frac{1}{1 + \exp(-z)}
\]</div>
<p>which is bounded between zero and one, and looks like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def sigmoid(z):
    return 1 / (1 + np.exp(-z))


z = np.linspace(-10, 10, 100)
plt.figure(figsize=(4,3))
plt.plot(z, sigmoid(z))
plt.xlabel(&quot;z&quot;)
plt.ylabel(&quot;sigmoid(z)&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;sigmoid(z)&#39;)
</pre></div>
</div>
<img alt="../_images/02_logistic_regression_7_1.png" src="../_images/02_logistic_regression_7_1.png" />
</div>
</div>
<p>The logistic regression model is:</p>
<div class="math notranslate nohighlight">
\[
\hat{y} = \textrm{sigmoid}(w x + b)
\]</div>
<p>Note we still use a <em>linear predictor</em>, <span class="math notranslate nohighlight">\(z\)</span>:</p>
<div class="math notranslate nohighlight">
\[
z = wx + b
\]</div>
<p>on the input features, which we apply the sigmoid function to create our final output (mapping the continuous value of the linear predictor to be between zero and one):</p>
<div class="math notranslate nohighlight">
\[
\hat{y} = \textrm{sigmoid}(z)
\]</div>
</section>
<section id="loss-function">
<h2>Loss Function<a class="headerlink" href="#loss-function" title="Permalink to this headline">#</a></h2>
<p>In linear regression we used mean squared error as the metric to optimise the weights of the model. In logistic regression we use the <strong>log loss</strong>, also known as the <strong>(binary) cross-entropy</strong> loss. It’s defined as follows (remember that <span class="math notranslate nohighlight">\(y\)</span>, the true class, is always zero or one):</p>
<div class="math notranslate nohighlight">
\[
\mathcal{L} = - \frac{1}{N} \sum_i^N y_i \log(\hat{y_i}) + (1 - y_i)\log(1 - \hat{y_i})
\]</div>
<p>Which looks like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>yhat = np.linspace(0.01, 0.99, 99)
plt.figure(figsize=(5, 4))
plt.plot(yhat, -np.log(yhat), label=&quot;y = 1&quot;)
plt.plot(yhat, -np.log(1 - yhat), label=&quot;y = 0&quot;)
plt.legend(loc=&quot;upper center&quot;)
plt.xlabel(r&quot;$\hat{y}$ (prediction)&quot;)
plt.ylabel(&quot;loss&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;loss&#39;)
</pre></div>
</div>
<img alt="../_images/02_logistic_regression_10_1.png" src="../_images/02_logistic_regression_10_1.png" />
</div>
</div>
</section>
<section id="why-not-just-use-mean-squared-error">
<h2>Why not just use mean squared error?<a class="headerlink" href="#why-not-just-use-mean-squared-error" title="Permalink to this headline">#</a></h2>
<section id="it-s-the-maximum-likelihood-estimator">
<h3>1) It’s the Maximum Likelihood Estimator<a class="headerlink" href="#it-s-the-maximum-likelihood-estimator" title="Permalink to this headline">#</a></h3>
<p>In logistic regression we model the true class label (<span class="math notranslate nohighlight">\(y_i=1\)</span> or <span class="math notranslate nohighlight">\(y_i=0\)</span>) as being drawn from a <em>Bernoulli distribution</em>, where the probability of <span class="math notranslate nohighlight">\(y_i = 1\)</span> is given by our prediction <span class="math notranslate nohighlight">\(\hat{y_i}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
p(y_i \mid \hat{y_i}) = 
\begin{cases}
    \hat{y_i} &amp; \text{if } y_i = 1 \\
    1-\hat{y_i} &amp; \text{if } y_i = 0
\end{cases}
\end{split}\]</div>
<p>We want to maximise the <em>likelihood</em> (the probability of the true class values given our predictions):</p>
<div class="math notranslate nohighlight">
\[
P(y \mid \hat{y}) = \prod_{i=1}^N p(y_i \mid \hat{y_i})
\]</div>
<p>Often it’s more convenient to work with the <em>log likelihood</em> instead:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\log \left[ P(y \mid \hat{y}) \right] =
\sum_{i=1}^N
\begin{cases}
    \log(\hat{y_i}) &amp; \text{if } y_i = 1 \\
    \log(1-\hat{y_i}) &amp; \text{if } y_i = 0
\end{cases}
\end{split}\]</div>
<p>Note the change from a product to a sum follows from log rules (<span class="math notranslate nohighlight">\(\log (ab) = \log(a) + \log(b)\)</span>).</p>
<p>This can be re-written as:</p>
<div class="math notranslate nohighlight">
\[
\log \left[ P(y \mid \hat{y}) \right] = \sum_{i=1}^N \left[ y_i \log(\hat{y_i}) + (1 - y_i) \log(1-\hat{y_i}) \right]
\]</div>
<p>In logistic regression with gradient descent, rather than maximising the log likelihood we minimise its negative and take the mean across the dataset:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{L} = - \frac{1}{N} \sum_{i=1}^N  \left[ y_i \log(\hat{y_i}) + (1 - y_i)\log(1 - \hat{y_i}) \right]
\]</div>
<p>This is exactly the <em>binary cross-entropy loss</em> introduced before.</p>
</section>
<section id="it-s-convex">
<h3>2) It’s convex<a class="headerlink" href="#it-s-convex" title="Permalink to this headline">#</a></h3>
<p>It’s a convex function for logistic regression (but mean squared error is not), see below. So it’s easier to optimise, as there are no local minima.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ws = np.linspace(-25, 35, 200)
bs = np.linspace(-10, 10, 200)

mse_ls = []
bce_ls = []
w_plot = []
b_plot = []
for w, b in itertools.product(ws, bs):
    w_plot.append(w)
    b_plot.append(b)
    yhat = sigmoid(w * x + b)
    mse_ls.append(mean_squared_error(y, yhat))
    bce_ls.append(log_loss(y, yhat))

fig, ax = plt.subplots(1, 2, subplot_kw={&quot;projection&quot;: &quot;3d&quot;}, figsize=(10, 8))

surf = ax[0].plot_surface(
    np.array(w_plot).reshape((len(ws), len(bs))),
    np.array(b_plot).reshape((len(ws), len(bs))),
    np.array(mse_ls).reshape((len(ws), len(bs))),
    cmap=&quot;viridis&quot;
)
ax[0].set_title(&quot;Mean Squared Error&quot;)
ax[0].set_xlabel(&quot;w&quot;)
ax[0].set_ylabel(&quot;b&quot;)
ax[0].set_zlabel(&quot;loss&quot;)

# Plot the surface.
surf = ax[1].plot_surface(
    np.array(w_plot).reshape((len(ws), len(bs))),
    np.array(b_plot).reshape((len(ws), len(bs))),
    np.array(bce_ls).reshape((len(ws), len(bs))),
    cmap=&quot;viridis&quot;
)
ax[1].set_title(&quot;Log Loss&quot;)
ax[1].set_xlabel(&quot;w&quot;)
ax[1].set_ylabel(&quot;b&quot;)
ax[1].set_zlabel(&quot;loss&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 0, &#39;loss&#39;)
</pre></div>
</div>
<img alt="../_images/02_logistic_regression_14_1.png" src="../_images/02_logistic_regression_14_1.png" />
</div>
</div>
</section>
</section>
<section id="gradient-descent-for-logistic-regression">
<h2>Gradient Descent for Logistic Regression<a class="headerlink" href="#gradient-descent-for-logistic-regression" title="Permalink to this headline">#</a></h2>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathcal{L} = - \frac{1}{N} \sum_{i=1}^N  \left[ y_i \log(\hat{y_i}) + (1 - y_i)\log(1 - \hat{y_i}) \right] \\
\hat{y_i} = \mathrm{sigmoid}(z_i) = \mathrm{sigmoid}(w x_i + b)
\end{split}\]</div>
<p>In gradient descent we iteratively update the parameters based on the gradient of the loss with respect to them, with a step size given by a learning rate <span class="math notranslate nohighlight">\(\alpha\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
w = w - \alpha \frac{\partial \mathcal{L}}{\partial w} \\
b = b - \alpha \frac{\partial \mathcal{L}}{\partial b} \\
\end{split}\]</div>
<p>The aim is to reach the minimum value of the loss, where the gradients are zero.</p>
<p>For logistic regression the gradients are given by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\frac{\partial \mathcal{L}}{\partial w} = \frac{1}{N} \sum_{i=1}^N  (\hat{y_i} - y_i) x_i \\
\frac{\partial \mathcal{L}}{\partial b} = \frac{1}{N} \sum_{i=1}^N  (\hat{y_i} - y_i)
\end{split}\]</div>
<p>To derive these you need to know the derivative of the sigmoid function and the chain rule from calculus, which we’ll see in the next notebook.</p>
</section>
<section id="neural-network-for-logistic-regression">
<h2>Neural Network for Logistic Regression<a class="headerlink" href="#neural-network-for-logistic-regression" title="Permalink to this headline">#</a></h2>
<p>To modify our simple linear regression neural network for logistic regression we need to add an <strong>activation function</strong>:</p>
<p><img alt="" src="../_images/02_logistic_regression_net.png" /></p>
<p>Where <span class="math notranslate nohighlight">\(z\)</span> is still the a linear combination of the output node’s inputs:</p>
<div class="math notranslate nohighlight">
\[
z = w_1 x_1 + w_2 x_2 + b
\]</div>
<p>which then has the <strong>sigmoid activation function</strong>, <span class="math notranslate nohighlight">\(g(z)\)</span>, applied to it to create the final output:</p>
<div class="math notranslate nohighlight">
\[
g(z) = \textrm{sigmoid}(z) = \frac{1}{1 + \exp(-z)}
\]</div>
<p>Often you’ll see <span class="math notranslate nohighlight">\(g(z)\)</span> (i.e. the computation of <span class="math notranslate nohighlight">\(z\)</span> and the application of <span class="math notranslate nohighlight">\(g\)</span>) drawn as a single node in diagrams, rather than explicitly separating them.</p>
</section>
<section id="pytorch">
<h2>Pytorch<a class="headerlink" href="#pytorch" title="Permalink to this headline">#</a></h2>
<p>Here is a logistic regression “neural network” implemented in pytorch, which we’ll use with the <code class="docutils literal notranslate"><span class="pre">BCELoss</span></code> (Binary Cross Entropy, aka the log loss defined earlier). Initially just for the dummy dataset we’ve used so far with a single input feature:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model = nn.Sequential(
    nn.Linear(in_features=1, out_features=1),
    nn.Sigmoid()
)
print(model)

loss_fn = nn.BCELoss()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Sequential(
  (0): Linear(in_features=1, out_features=1, bias=True)
  (1): Sigmoid()
)
</pre></div>
</div>
</div>
</div>
<p>For improved numerical stability (see <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.BCEWithLogitsLoss.html">the pytorch docs</a> and <a class="reference external" href="https://gregorygundersen.com/blog/2020/02/09/log-sum-exp/">this article</a> for details) it’s preferred to combine the sigmoid and loss functions into one step. This is done by using <code class="docutils literal notranslate"><span class="pre">BCEWithLogitsLoss</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model = nn.Sequential(
    nn.Linear(in_features=1, out_features=1),
)
print(model)

loss_fn = nn.BCEWithLogitsLoss()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Sequential(
  (0): Linear(in_features=1, out_features=1, bias=True)
)
</pre></div>
</div>
</div>
</div>
<p>Note that sigmoid no longer appears in the network definition, and if the model is trained this way its output will be <span class="math notranslate nohighlight">\(z\)</span>, not <span class="math notranslate nohighlight">\(g(z)\)</span> (i.e. we need to apply the sigmoid function to the output to recover the class probabilities).</p>
<p>Everything else about training the network is the same we saw in the first part for linear regression:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>learning_rate = 0.01
optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def train(X, y, model, loss_fn, optimizer, epochs):
    loss_history = []
    for e in range(epochs):
        # Compute prediction and loss
        pred = model(X)
        loss_value = loss_fn(pred, y)
        loss_history.append(float(loss_value))

        # Backpropagation
        optimizer.zero_grad()
        loss_value.backward()
        optimizer.step()

    print(&quot;Done!&quot;)
    return model, loss_history
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x = torch.tensor(x, dtype=torch.float)
y = torch.tensor(y, dtype=torch.float)
x = x[:, None]
y = y[:, None]  # input and output needs to be 2D, [:, None] adds a second (length 1) axis
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model, loss_history = train(x, y, model, loss_fn, optimizer, 15000)

for name, param in model.named_parameters():
    print(f&quot;Layer: {name} | Size: {param.size()} | Values : {param[:]} \n&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Done!
Layer: 0.weight | Size: torch.Size([1, 1]) | Values : tensor([[5.4467]], grad_fn=&lt;SliceBackward0&gt;) 

Layer: 0.bias | Size: torch.Size([1]) | Values : tensor([0.8172], grad_fn=&lt;SliceBackward0&gt;) 
</pre></div>
</div>
</div>
</div>
<p>Here’s the fit to the data:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, ax = plt.subplots(1, 2, figsize=(9, 3))
ax[0].plot(loss_history)
ax[0].set_xlabel(&quot;epochs&quot;)
ax[0].set_ylabel(&quot;loss&quot;)

yhat = sigmoid(model(x).detach().numpy())  # need to apply sigmoid here due to use of BCEWithLogitsLoss
ax[1].scatter(x, y, c=yhat&gt;=0.5, cmap=&quot;bwr&quot;)
ax[1].plot(x, yhat, &quot;k--&quot;, label=&quot;sigmoid fit&quot;)
ax[1].set_xlabel(&quot;x&quot;)
ax[1].set_ylabel(&quot;y&quot;)
boundary = - model[0].bias[0].detach() / model[0].weight[0][0].detach()
ax[1].plot([boundary, boundary], [-0.1, 1.1], &quot;g&quot;, linewidth=3, label=&quot;decision boundary&quot;)
ax[1].set_ylim([-0.05, 1.05])
ax[1].legend(loc=&quot;lower right&quot;)

fig.tight_layout()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/02_logistic_regression_27_0.png" src="../_images/02_logistic_regression_27_0.png" />
</div>
</div>
<p>Also shown is the <strong>decision boundary</strong> - all samples with <span class="math notranslate nohighlight">\(x\)</span> to the left of the boundary are predicted to have <span class="math notranslate nohighlight">\(y = 0\)</span>, and all values to the right <span class="math notranslate nohighlight">\(y = 1\)</span> (assuming we predict <span class="math notranslate nohighlight">\(y = 1\)</span> when <span class="math notranslate nohighlight">\(\hat{y} \geq 0.5\)</span>).</p>
</section>
<section id="adding-a-second-feature">
<h2>Adding a second feature<a class="headerlink" href="#adding-a-second-feature" title="Permalink to this headline">#</a></h2>
<p>Now let’s consider a more interesting dataset with two features, <span class="math notranslate nohighlight">\(x_1\)</span>, <span class="math notranslate nohighlight">\(x_2\)</span>, and a non-linear decision boundary. In this case samples belong to class 1 if <span class="math notranslate nohighlight">\(x_1^3 - x_1 - x_2 &gt; 0\)</span> (and class 0 otherwise):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def get_cubic_data(n=1000):
    X = np.random.normal(size=(n, 2))
    y = X[:, 1] &lt; (X[:, 0] ** 3) - X[:, 0]
    return X, y


X, y = get_cubic_data()

fig, ax = plt.subplots(1, 2, figsize=(9.5, 4))

ax[0].scatter(X[:, 0], X[:, 1], c=y, cmap=&quot;bwr&quot;, s=18)
ax[0].set_xlabel(&quot;$x_1$&quot;)
ax[0].set_ylabel(&quot;$x_2$&quot;)
x_span = np.linspace(X[:, 0].min() - 1, X[:, 0].max() + 1, 1000)
ax[0].plot(x_span, x_span ** 3 - x_span, &quot;k--&quot;, label=&quot;$x_1^3 - x_1 - x_2 = 0$&quot;)
ax[0].set_ylim([-4, 4])
ax[0].legend()

z = X[:, 0] ** 3 - X[:, 0] - X[:, 1]
ax[1].scatter(z, y, c=y, cmap=&quot;bwr&quot;)
ax[1].plot([0, 0], [-0.1, 1.1], &quot;k--&quot;, label=&quot;$x_1^3 - x_1 - x_2 = 0$&quot;)
ax[1].legend()
ax[1].set_xlabel(&quot;$x_1^3 - x_1 - x_2$&quot;)
ax[1].set_ylabel(&quot;y&quot;)

fig.tight_layout()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/02_logistic_regression_30_0.png" src="../_images/02_logistic_regression_30_0.png" />
</div>
</div>
</section>
<section id="pytorch-2-input-logistic-regression-network">
<h2>Pytorch 2-input Logistic Regression Network<a class="headerlink" href="#pytorch-2-input-logistic-regression-network" title="Permalink to this headline">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model = nn.Sequential(
    nn.Linear(in_features=2, out_features=1),  # 2 input features now (x_1, x_2)
    # Sigmoid (applied in loss_fn)
)

loss_fn = nn.BCEWithLogitsLoss()
# Reminder: BCEWithLogitsLoss both applies sigmoid to the output and computes the loss
</pre></div>
</div>
</div>
</div>
</section>
<section id="what-type-of-decision-boundary-can-this-network-fit-given-x-1-and-x-2">
<h2>What type of decision boundary can this network fit (given <span class="math notranslate nohighlight">\(x_1\)</span> and <span class="math notranslate nohighlight">\(x_2\)</span>)?<a class="headerlink" href="#what-type-of-decision-boundary-can-this-network-fit-given-x-1-and-x-2" title="Permalink to this headline">#</a></h2>
<p>a) Linear</p>
<p>b) Non-linear</p>
<p>Reminder: We’ve added a non-linear activation function (sigmoid)</p>
</section>
<section id="result">
<h2>Result<a class="headerlink" href="#result" title="Permalink to this headline">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>X = torch.tensor(X, dtype=torch.float)
y = torch.tensor(y, dtype=torch.float)
y = y[:, None]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def plot_decision_boundary(
    dataset,
    labels,
    model,
    steps=1000,
    cmap=&quot;bwr&quot;,
    ax=None,
    show_data=True,
    show_actual=True,
    title=&quot;Decision Boundary Fit&quot;,
    xlim=None,
    ylim=None,
    xlabel=&quot;$x_1$&quot;,
    ylabel=&quot;$x_2$&quot;,
    alpha=0.25,
    fig=None,
    vmin=0,
    vmax=1,
):
    &quot;&quot;&quot;
    Adapted from:
    https://gist.github.com/erwan-simon/e3baef06a00bb9a39a6968acf78121ee
    &quot;&quot;&quot;
    # Define region of interest by data limits
    if xlim:
        xmin, xmax = xlim
    else:
        xmin, xmax = dataset[:, 0].min() - 1, dataset[:, 0].max() + 1
    if ylim:
        ymin, ymax = ylim
    else:
        ymin, ymax = dataset[:, 1].min() - 1, dataset[:, 1].max() + 1
    if ax is None:
        fig, ax = plt.subplots()
    if fig is None:
        fig = ax.get_figure()

    x_span = np.linspace(xmin, xmax, steps)
    y_span = np.linspace(ymin, ymax, steps)
    xx, yy = np.meshgrid(x_span, y_span)

    # Make predictions
    labels_predicted = model(
        torch.tensor(np.c_[xx.ravel(), yy.ravel()], dtype=torch.float)
    )
    labels_predicted = sigmoid(labels_predicted.detach().numpy())

    # Plot predictions
    z = np.array(labels_predicted).reshape(xx.shape)
    cf = ax.contourf(xx, yy, z, cmap=cmap, alpha=alpha, vmin=vmin, vmax=vmax)
    
    divider = make_axes_locatable(ax)
    cax = divider.new_horizontal(size=&quot;5%&quot;, pad=0.2)
    fig.add_axes(cax)
    fig.colorbar(cf, cax=cax)

    # plot data
    if show_data:
        ax.scatter(
            dataset[:, 0],
            dataset[:, 1],
            c=labels.reshape(labels.size()[0]),
            cmap=cmap,
            lw=0,
            marker=&quot;.&quot;
        )
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    ax.set_title(title)
    if not show_data and show_actual:
        ax.plot(x_span, x_span ** 3 - x_span, &quot;k--&quot;, label=&quot;actual&quot;)
        ax.set_ylim([ymin, ymax])
        ax.legend()


def show_result(X, y, model, loss_history, print_weights=True, suptitle=&quot;&quot;):
    if print_weights:
        for name, param in model.named_parameters():
            print(f&quot;Layer: {name} | Size: {param.size()} | Values : {param[:]} \n&quot;)

    fig, ax = plt.subplots(1, 3, figsize=(10, 3))
    ax[0].plot(loss_history)
    ax[0].set_xlabel(&quot;epoch&quot;)
    ax[0].set_ylabel(&quot;loss&quot;)
    plot_decision_boundary(X, y, model, ax=ax[1], show_data=False)
    plot_decision_boundary(X, y, model, ax=ax[2], show_data=True, title=&quot;Data&quot;)
    fig.suptitle(suptitle)
    fig.tight_layout()
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>learning_rate = 0.1
optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)
model, loss_history = train(X, y, model, loss_fn, optimizer, 5000)

show_result(X, y, model, loss_history)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Done!
Layer: 0.weight | Size: torch.Size([1, 2]) | Values : tensor([[ 1.4855, -3.4504]], grad_fn=&lt;SliceBackward0&gt;) 

Layer: 0.bias | Size: torch.Size([1]) | Values : tensor([-0.0212], grad_fn=&lt;SliceBackward0&gt;) 
</pre></div>
</div>
<img alt="../_images/02_logistic_regression_37_1.png" src="../_images/02_logistic_regression_37_1.png" />
</div>
</div>
<p>Logistic regression, and our neural network that recreates it, can only fit <em>linear</em> decision boundaries. We could fit a non-linear boundary by adding polynomial features. In this case we’d need up cubic terms so we might try to fit something like this:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
z = w_1 x_1^3 + w_2 x_1^2 x_2 + w_3 x_1 x_2^2 + w_4 x_2^3 + w_5 x_1 ^2 + w_6 x_1 x_2 + w_7 x_2^2 + w_8 x_1 + w_9 x_2 + b \\
\hat{y} = \textrm{sigmoid}(z)
\end{split}\]</div>
<p>Note that <span class="math notranslate nohighlight">\(z\)</span> is linear in the weights so this is still logistic regression.</p>
<p>Could neural networks provide an alternative to creating all these features manually?</p>
</section>
<section id="adding-nodes-and-layers-moving-away-from-logistic-regression">
<h2>Adding nodes and layers (moving away from logistic regression)<a class="headerlink" href="#adding-nodes-and-layers-moving-away-from-logistic-regression" title="Permalink to this headline">#</a></h2>
<p>For our linear regression network with <strong>no/linear/identity activation</strong> we saw adding nodes and layers had no effect on the type of function that could be fitted. How about adding nodes/layers to our logistic regression network, which has <strong>sigmoid activation</strong>?</p>
<section id="hidden-layer">
<h3>1 Hidden Layer<a class="headerlink" href="#hidden-layer" title="Permalink to this headline">#</a></h3>
<p>Let’s add a hidden layer with 2 nodes:</p>
<p><img alt="" src="../_images/02_1hidden.png" /></p>
<p>Note that we’re also applying the activation function (in this case sigmoid) on the output of the hidden nodes.</p>
<section id="what-type-of-decision-boundary-can-this-network-fit-given-only-the-original-features-x-1-and-x-2">
<h4>What type of decision boundary can this network fit (given only the original features <span class="math notranslate nohighlight">\(x_1\)</span> and <span class="math notranslate nohighlight">\(x_2\)</span>)?<a class="headerlink" href="#what-type-of-decision-boundary-can-this-network-fit-given-only-the-original-features-x-1-and-x-2" title="Permalink to this headline">#</a></h4>
<p>a) Linear</p>
<p>b) Non-linear</p>
<p>Let’s see. Here’s the new network in pytorch:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model = nn.Sequential(
    nn.Linear(in_features=2, out_features=2),
    nn.Sigmoid(),
    nn.Linear(in_features=2, out_features=1),
    #  Sigmoid (applied in loss_fn)
)

learning_rate = 0.2
optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)
model, loss_history = train(X, y, model, loss_fn, optimizer, 30000)

show_result(X, y, model, loss_history)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Done!
Layer: 0.weight | Size: torch.Size([2, 2]) | Values : tensor([[-1.4876,  0.7145],
        [-9.5315, -9.2478]], grad_fn=&lt;SliceBackward0&gt;) 

Layer: 0.bias | Size: torch.Size([2]) | Values : tensor([-0.0268, -0.0696], grad_fn=&lt;SliceBackward0&gt;) 

Layer: 2.weight | Size: torch.Size([1, 2]) | Values : tensor([[-24.2499,  14.3516]], grad_fn=&lt;SliceBackward0&gt;) 

Layer: 2.bias | Size: torch.Size([1]) | Values : tensor([4.7237], grad_fn=&lt;SliceBackward0&gt;) 
</pre></div>
</div>
<img alt="../_images/02_logistic_regression_43_1.png" src="../_images/02_logistic_regression_43_1.png" />
</div>
</div>
<p>We get a non-linear decision boundary! But there’s still a region where the network is uncertain/misclassifies  some points (e.g. the white region). What if we add another layer?</p>
</section>
</section>
<section id="hidden-layers">
<h3>2 Hidden Layers<a class="headerlink" href="#hidden-layers" title="Permalink to this headline">#</a></h3>
<p><img alt="" src="../_images/02_2hidden.png" /></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model = nn.Sequential(
    nn.Linear(in_features=2, out_features=3),
    nn.Sigmoid(),
    nn.Linear(in_features=3, out_features=3),
    nn.Sigmoid(),
    nn.Linear(in_features=3, out_features=1),
    #  Sigmoid (applied in loss_fn)
)

learning_rate = 0.2
optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)
model, loss_history = train(X, y, model, loss_fn, optimizer, 30000)

show_result(X, y, model, loss_history, print_weights=False)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Done!
</pre></div>
</div>
<img alt="../_images/02_logistic_regression_46_1.png" src="../_images/02_logistic_regression_46_1.png" />
</div>
</div>
<p>This network can almost perfectly fit the decision boundary the data was generated with.</p>
</section>
</section>
<section id="what-s-going-on">
<h2>What’s going on?<a class="headerlink" href="#what-s-going-on" title="Permalink to this headline">#</a></h2>
<p>Let’s go back to the one hidden layer network:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model = nn.Sequential(
    nn.Linear(in_features=2, out_features=2),
    nn.Sigmoid(),
    nn.Linear(in_features=2, out_features=1),
    #  Sigmoid (applied in loss_fn)
)

learning_rate = 0.2
optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)
model, loss_history = train(X, y, model, loss_fn, optimizer, 30000)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Done!
</pre></div>
</div>
</div>
</div>
<p>We can visualise the input and output of each node to get an idea of how the non-linear decision boundary is created:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, ax = plt.subplots(2, 2, figsize=(8, 7))

# 1st hidden node
w00 = model[0].weight[0]
b00 = model[0].bias[0]
fn00 = lambda x: (w00 * x + b00).sum(axis=1)
g00 = sigmoid(fn00(X).detach())

plot_decision_boundary(
    X,
    y,
    fn00,
    show_data=False,
    show_actual=True,
    ax=ax[0][0],
    title=&quot;Hidden Node 1&quot;,
)

# 2nd hidden node
w01 = model[0].weight[1]
b01 = model[0].bias[1]
fn01 = lambda x: (w01 * x + b01).sum(axis=1)
g01 = sigmoid(fn01(X).detach())

plot_decision_boundary(
    X,
    y,
    fn01,
    show_data=False,
    show_actual=True,
    ax=ax[0][1],
    title=&quot;Hidden Node 2&quot;,
)

# Output node
a1 = np.array([g00.numpy(), g01.numpy()]).T  # output of hidden layer
fn10 = (
    lambda a1: model[2].weight[0][0] * a1[:, 0]
    + model[2].weight[0][1] * a1[:, 1]
    + model[2].bias
)

# Output vs. hiddden node activations
plot_decision_boundary(
    a1,
    y,
    fn10,
    show_data=True,
    ax=ax[1][0],
    show_actual=False,
    xlim=(-0.01, 1.01),
    ylim=(-0.01, 1.01),
    title=&quot;Output Layer\n(activation of hidden nodes)&quot;,
    xlabel=&quot;Hidden Node 1 Activation&quot;,
    ylabel=&quot;Hidden Node 2 Activation&quot;,
)


# Output vs. input data values
plot_decision_boundary(
    X,
    y,
    model,
    show_data=True,
    show_actual=False,
    ax=ax[1][1],
    title=&quot;Output Layer\n(input features)&quot;,
)

fig.tight_layout()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/02_logistic_regression_51_0.png" src="../_images/02_logistic_regression_51_0.png" />
</div>
</div>
<p>The colour scale shows the “activation” of the node (i.e. the output after applying the sigmoid function). One node in the hidden layer captures the upward (positive) slope of the decision boundary, and the other the downward (negative) slope. When combined in the output layer (and sigmoid applied), the points from the two classes are linearly separable (you can draw a linear decision boundary between them) with respect to the activation of the hidden nodes.</p>
</section>
<section id="takeaway-message">
<h2>Takeaway message<a class="headerlink" href="#takeaway-message" title="Permalink to this headline">#</a></h2>
<p>Adding non-linear activation functions (e.g. sigmoid) to the output of every node allows us to fit non-linear functions with neural networks.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://allenkunle.me/deriving-ml-cost-functions-part2"><em>“Deriving Machine Learning Cost Functions using Maximum Likelihood Estimation (MLE) - Part II”</em></a>, Allen Akinkunle</p></li>
<li><p><a class="reference external" href="https://www.coursera.org/learn/machine-learning?specialization=machine-learning-introduction#syllabus"><em>“Supervised Machine Learning: Regression and Classification”</em></a> (Coursera), Andrew Ng</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="01_linear_regression.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">01: Linear Regression</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="03_backprop.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">03: Back Propagation</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Jack Roberts<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>